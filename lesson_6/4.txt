
Вся проблема здесь в контексте функции, которую мы вызываем. Контекст - это this, точнее то, что под this имеется ввиду, что лежит в this. Посмотрите при обоих вариантах что лежит в this, проверьте сами.

Если бы мы написали так:

```
closeImageElement.addEventListener('click', this.close);
```

тогда при вызове метода close в this лежал бы не объект галереи, а объект при котором произошло событие, в нашем случае клик был по картинке с крестиком, вот в this и будет лежать элемент этой картинки.
Вы скажете, а как же объект gallery? Где он? А этот контекст теряется в таком случае.

Если же мы напишем:

```
closeImageElement.addEventListener('click', () => this.close());
```

что в таком случае? В таком случае вызовется анонимная стрелочная функция, дело в том, что стрелочная функция не имеет контекста, она берет тот контекст, который существует в области видимости выше, вне ее (в нашем случае это как раз gallery), т.е. внутри этой анонимной функции this будет gallery, а не элемент картинки на которую кликнули как было раньше. Внутри этой функции мы уже вызываем метод объекта gallery используя this.

Можно ли стрелочную функцию заменить на function? Т.е. написать так:

```
closeImageElement.addEventListener('click', function() { this.close(); });
```

Нет, работать это не будет снова по той же причине что и выше, функция принимает контекст, поэтому this внутри этой функции будет картинка, а не объект gallery. Можно использовать метод bind, чтобы указать четко какой контекст будет внутри функции при ее вызове:

```
closeImageElement.addEventListener('click', this.close.bind(this));
```

Сейчас при вызове метода close объекта gallery контекст будет привязан четко заданный - сам объект gallery.
